\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{NURBS curve implementation}
\label{chp:nurbsimplementation}

For the purpose of path planning for autonomous guided vehicles, a C++ library
was created for the implementation and manipulation of NURBS curves. The library
utilizes the Eigen library for its linear algebra functions.

The library implements all necessary functions for creating and using NURBS
curves. Elementary transformations, such as translation and rotation, are not
implemented. It is important to note one of the properties of NURBS curves which
is that all transformations applied to the set of control points are equivalent
to transformations on the curve itself, meaning that the end-user may implement
these functions themselves if necessary. The library only provides the minimum
required functions to cover all operations exclusive to NURBS curves.

\section{The Eigen library}

\emph{Eigen} is an open-source C++ template library for linear algebra
\cite{eigenweb}. It is commonly used in the fields of computer graphics and
robotics. The library provides class and function templates that allow for
compile-time optimization, as well as \emph{SIMD} ("single instruction, multiple
data") vectorization which drastically speeds up operations on vectors and
matrices. Using \emph{Eigen's} built-in vector and matrix classes allows for
interoperability with other libraries and end-user programs that use
\emph{Eigen}, which is often the case in robotics.

\section{Class structure}

The main data structure that is available to the user is the \texttt{Curve} class. A
curve is divided into knot spans, or segments of the curve between two adjacent
knots, which are represented by the \texttt{Span} utility class. A Curve object manages
its own Span objects which are not visible outside of the class, nor is the Span
class itself visible to the end user.

\subsection{Curve}

The \texttt{Curve} class represents a complete NURBS curve, i.e. sequence of
continuous knot spans. It stores some of the basic data of a particular curve,
including its control points, knot vector, and order. Internally it is
represented by an array of \emph{Span} objects containing the data required to
evaluate many NURBS operations, though they are not accessible to the end-user.

Methods that operate on a single span rather than the entire curve involve
evaluating which spans are being affected, then propagating the function call to
the \emph{Span} objects themselves. The \texttt{getKnotSpanIndex(t)} method
returns the index of the knot span containing the value $t$. The result is
always a single span and never a set of spans. If the value $t$ is itself a knot
with a multiplicity greater than one, the function returns the first span after
the multiple knot, and never the zero-length span containing the knot $t$.

\subsection{Span}

The \texttt{Span} class defines a segment of a curve between two knots. It
shares its order with its parent curve and the number of control points is
limited by its order. A single span does not have a knot vector. The shape of
a span is defined by its basis function, which is in turn defined by the parent
curve's knot vector. This basis function is defined in the code as a 4 by 4
matrix and is stored in each span.

For the sake of performance and memory efficiency, the \texttt{Span} class does
not store its control points, but instead caches the dot product of the weights
with the basis function, as well as the weighted control points with the basis
function, as required by Equation \eqref{eq:nurbs_point} for the evaluation of a
point on the curve.

Whenever the curve's knot vector is modified, the affected spans recompute their
basis functions as defined in Equation \eqref{eq:basisfunc}. Afterwards they
recompute their cached control point and weight matrices.

\section{Key method implementations}

\subsection{Creating a curve}

The \texttt{Curve} class has several constructors, however the main intended
method of instantiation is using a sequence of control points. The curve's order
defaults to three but can be specified. The knot vector is optional, and if it
is not provided a uniformly spaced knot vector is generated. As per the
definition of NURBS, the number of control points for a curve of degree $p$ must
be equal or greater than $p+1$. Given a sequence of $N$ control points, an order
$p$ and a knot vector, the constructor generates $N-p$ \texttt{Span} objects.

The \texttt{Span} constructor takes a subset of control points, a subset of a
knot vector and the span's order. None of the arguments are optional. The first
step is to generate the span's basis function based on the given knot vector
segment and the given order. The basis function is computed according to
Equation \eqref{eq:basisfunc} and stored in the span. Using the basis function
and the weighted control point segment the span computes the product of the
basis function with the control point matrix, and the basis function with the
weight vector, named \texttt{cached\_vbf\_} and \texttt{cached\_wbf\_} respectively.
With these data members calculated the span is returned and stored in the curve
object.

\subsection{Curve and span methods}

The \texttt{valueAt} method directly implements equation \eqref{eq:nurbs_point}
using matrix notation. The helper function \texttt{\_powSeries(t, p)} computes the
powers of $t$ up to $p$.

The \texttt{length} method calculates the total length of a curve. 

\subsection{Piecewise linear representation}

The \texttt{polyline} method creates a sequence of points suitable for
drawing or other purposes when only an approximation of the curve is needed. One
possible way, and the simplest way to implement this would be to iterate over a
fixed number of uniformly spaced $t$ values, however this can cause problems as
it does not take into account the scale of the curve and its curvature; a curve
could have the same number of points as another curve ten times its length, and
a curve that is equal to a straight line could have the same number of points as
one with many sharp twists.

The \texttt{polyline} method takes a \texttt{flatness} argument which defines
the tolerance for the distance between the linear approximation and the actual
curve.

For each segment of the curve, the method checks $p-1$ points and finds the
maximum distance from the line segment created by the segment's beginning and
end point. Using $p-1$ points makes it impossible for the maximum distance to
be determined as the intersection of the line and curve, which would be possible
with fewer points.

% dijagram kako izgleda kad se gleda samo midpoint, vs kad se gledaju dvije
% toƒçke za span reda 3



\end{document}