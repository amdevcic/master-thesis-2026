\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{NURBS curve implementation}
\label{chp:nurbsimplementation}

For the purpose of path planning for autonomous guided vehicles, a C++ library
was created for the implementation and manipulation of NURBS curves. The library
utilizes the Eigen library for its linear algebra functions.

The library implements all necessary functions for creating and using NURBS
curves. Elementary transformations, such as translation and rotation, are not
implemented. It is important to note one of the properties of NURBS curves which
is that all transformations applied to the set of control points are equivalent
to transformations on the curve itself, meaning that the end-user may implement
these functions themselves if necessary. The library only provides the minimum
required functions to cover all operations exclusive to NURBS curves.

\section{The Eigen library}

\emph{Eigen} is an open-source C++ template library for linear algebra
\cite{eigenweb}. It is commonly used in the fields of computer graphics and
robotics. The library provides class and function templates that allow for
compile-time optimization, as well as \emph{SIMD} ("single instruction, multiple
data") vectorization which drastically speeds up operations on vectors and
matrices. Using \emph{Eigen's} built-in vector and matrix classes allows for
interoperability with other libraries and end-user programs that use
\emph{Eigen}, which is often the case in robotics.

Most of Eigen's functionality revolves around its \texttt{DenseBase} class which
serves as a parent class to all dense matrices and vectors. Two subclasses which
will be relevant for the implementation of NURBS are the \texttt{Matrix} and
\texttt{Vector} classes, which are further subclassed to describe matrices and
vectors of specific dimensions. Some examples of these subclasses are
\texttt{Matrix2Xd}, which describes a matrix of width 2 and an arbitrary height,
and \texttt{RowVectorXd} which describes a vector of height one and an arbitrary
width. Specifying these types at compile-time instead of using the generic
parent classes allows the compiler to optimize certain operations for
constant-size matrices instead of ones with a size only known at runtime.

\section{Class structure}

The main data structure that is available to the user is the \texttt{Curve}
class. A curve is divided into knot spans, or segments of the curve between two
adjacent knots, which are represented by the \texttt{Span} utility class. A
Curve object manages its own Span objects which are not visible outside of the
class, nor is the Span class itself visible to the end user.

\subsection{Curve}

The \texttt{Curve} class represents a complete NURBS curve, i.e. sequence of
continuous knot spans. It stores some of the basic data of a particular curve,
including its control points, knot vector, and order. Internally it is
represented by an array of \emph{Span} objects containing the data required to
evaluate many NURBS operations, though they are not accessible to the end-user.

Methods that operate on a single span rather than the entire curve involve
evaluating which spans are being affected, then propagating the function call to
the \emph{Span} objects themselves. The \texttt{getKnotSpanIndex(t)} method
returns the index of the knot span containing the value $t$. The result is
always a single span and never a set of spans. If the value $t$ is itself a knot
with a multiplicity greater than one, the function returns the first span after
the multiple knot, and never the zero-length span containing the knot $t$.

\subsection{Span}

The \texttt{Span} class defines a segment of a curve between two knots. It
shares its order with its parent curve and the number of control points is
limited by its order. A single span does not have a knot vector. The shape of a
span is defined by its basis function, which is in turn defined by the parent
curve's knot vector. This basis function is defined in the code as a $(p+1)$ by
$(p+1)$ matrix, where $p$ represents the span's order, and is stored in each
span.

For the sake of performance and memory efficiency, the \texttt{Span} class does
not store its control points, but instead caches the dot product of the weights
with the basis function, as well as the weighted control points with the basis
function, as required by Equation \eqref{eq:nurbs_point} for the evaluation of a
point on the curve.

Whenever the curve's knot vector is modified, the affected spans use the
\texttt{update} method to recompute their basis functions as defined in Equation
\eqref{eq:basisfunc}. Afterwards they recompute their cached control point and
weight matrices using the \texttt{updateControlPoints} method.

\section{Key method implementations}

\subsection{Creating a curve}

The \texttt{Curve} class has several constructors, however the main intended
method of instantiation is using a sequence of control points. The curve's order
defaults to three but can be specified. The knot vector is optional, and if it
is not provided a uniformly spaced knot vector is generated. As per the
definition of NURBS, the number of control points for a curve of degree $p$ must
be equal or greater than $p+1$. Given a sequence of $N$ control points, an order
$p$ and a knot vector, the constructor generates $N-p$ \texttt{Span} objects.

The \texttt{Span} constructor takes a subset of control points, a subset of a
knot vector and the span's order. None of the arguments are optional. The first
step is to generate the span's basis function based on the given knot vector
segment and the given order. The basis function is computed according to
Equation \eqref{eq:basisfunc} and stored in the span. Using the basis function
and the weighted control point segment the span computes the product of the
basis function with the control point matrix, and the basis function with the
weight vector, named \texttt{cached\_vbf\_} and \texttt{cached\_wbf\_}
respectively. With these data members calculated the span is returned and stored
in the curve object.

\subsection{Curve and span methods}

The \texttt{valueAt} method directly implements equation \eqref{eq:nurbs_point}
using matrix notation. The helper function \texttt{\_powSeries(t, p)} computes
the powers of $t$ up to $p$.

The \texttt{length} method approximates the total length of a curve. Exact
calculation of the length of any parametric curve of the third degree or higher
is proven to be impossible. \citenone  The method instead uses Chebyshev
polynomials to approximate the length of the span with a negligible error.

\subsection{Piecewise linear representation}

The \texttt{polyline} method creates a sequence of points suitable for drawing
or other purposes when only an approximation of the curve is needed. One
possible way, and the simplest way to implement this would be to iterate over a
fixed number of uniformly spaced $t$ values, however this can cause problems as
it does not take into account the scale of the curve and its curvature; a curve
could have the same number of points as another curve ten times its length, and
a curve that is equal to a straight line could have the same number of points as
one with many sharp twists.

The \texttt{polyline} method takes a \texttt{flatness} argument which defines
the tolerance for the distance between the linear approximation and the actual
curve.

For each segment of the curve, the method checks $p-1$ points and finds the
maximum distance from the line segment created by the segment's beginning and
end point. Using $p-1$ points makes it impossible for the maximum distance to be
determined as the intersection of the line and curve, which would be possible
with fewer points.

% dijagram kako izgleda kad se gleda samo midpoint, vs kad se gledaju dvije
% toƒçke za span reda 3

\subsection{Derivative evaluation}

The \texttt{derivativeAt} method computes the $n$-th derivative of the curve on
a given point $t$. The order of the derivative is not limited, however higher
values for n can result in slow performance. The helper method
\texttt{\_powSeriesDerivative} calculates the derivative of the power series of
$t$, which amounts to differentiating each of the elements individually.

\begin{equation*}
    \begin{aligned}
        \mathbf{U}_k(t) &= \begin{bmatrix}
            1, t, t^2, t^3, \dots, t^k
        \end{bmatrix} \\
        \frac{d}{dt} \mathbf{U}_k(t) &= \begin{bmatrix}
            0, 1, 2t, 3t^2, \dots, kt^{k-1}
        \end{bmatrix} \\
        \frac{d^2}{dt^2} \mathbf{U}_k(t) &= \begin{bmatrix}
            0, 0, 2, 6t, \dots, k(k-1)t^{k-2}
        \end{bmatrix} \\
        \dots
    \end{aligned}
\end{equation*}

The \texttt{extrema} method calculates the positions of all extrema of the curve
on the $x$ and $y$ axis. One use case of this is calculating the bounding box of
the curve or span, as done in the \texttt{boundingBox} method in the
\texttt{Span} class. The \texttt{boundingBox} method in the \texttt{Curve}
class, on the other hand, gets the bounding boxes of all its spans and finds
their minimum and maximum.

\subsection{Curve and span splitting}

the \texttt{\_splittingCoeffs} helper function creates a pair of matrices which,
when multiplied with a span's basis function, splits the span into two new spans
at a given point $t$. \citenone

This function is used in methods such as \texttt{polyline} and
\texttt{intersections}, but also in the \texttt{Curve} class for literal curve
splitting.

\subsection{Intersections between curves}
Finding all intersections between two spans is known to be impossible. \citenone
Instead, an iterative method is used to approximate the intersections with an
error of \texttt{epsilon}.

The \texttt{intersections} method uses a similar algorithm to the
\texttt{polyline} method to determine if a span is approximately a straight line.

\end{document}