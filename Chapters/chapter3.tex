\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{NURBS curve implementation}
\label{chp:nurbsimplementation}

For the purpose of path planning for autonomous mobile robots, a C++ library was
created for the implementation and manipulation of NURBS curves. The library
utilizes the Eigen library for its linear algebra functions.

The library implements all necessary functions for creating and using NURBS
curves. Elementary transformations, such as translation and rotation, are not
implemented. It is important to note one of the properties of NURBS curves which
is that all affine transformations applied to the set of control points, as well
as perspective projections, are equivalent to transformations on the curve
itself, meaning that the end-user may implement these functions themselves if
necessary \cite{Piegl_Tiller_1997}. The library only provides the minimum
required functions to cover all operations exclusive to NURBS curves.

\section{The Eigen library}

\emph{Eigen} is an open-source C++ template library for linear algebra
\cite{eigenweb}. It is commonly used in the fields of computer graphics and
robotics. The library provides class and function templates that allow for
compile-time optimization, as well as \emph{SIMD} ("single instruction, multiple
data") vectorization which drastically speeds up operations on vectors and
matrices. Using \emph{Eigen's} built-in vector and matrix classes allows for
interoperability with other libraries and end-user programs that use
\emph{Eigen}, which is often the case in robotics.

Most of Eigen's functionality revolves around its \texttt{DenseBase} class which
serves as a parent class to all dense matrices and vectors. Two subclasses which
will be relevant for the implementation of NURBS are the \texttt{Matrix} and
\texttt{Vector} classes, which are further subclassed to describe matrices and
vectors of specific dimensions. Some examples of these subclasses are
\texttt{Matrix2Xd}, which describes a matrix of width 2 and an arbitrary height,
and \texttt{RowVectorXd} which describes a vector of height one and an arbitrary
width. Specifying these types at compile-time instead of using the generic
parent classes allows the compiler to optimize certain operations for
constant-size matrices instead of ones with a size only known at runtime.

Normally, matrix multiplication is an expensive operation, with $n\times n$
matrix multiplication having $O(n^3)$ time complexity, however Eigen's
vectorization and SIMD capabilities allow this to be much faster than
implementing it manually.

\section{Class structure}

The main data structure that is available to the user is the \texttt{Curve}
class. A curve is divided into knot spans, or segments of the curve between two
adjacent knots, which are represented by the \texttt{Span} utility class. A
\texttt{Curve} object manages its own \texttt{Span} objects which are not
visible outside of the class, nor is the Span class itself visible to the end
user.

\subsection{Curve}

The \texttt{Curve} class represents a complete NURBS curve, i.e. sequence of
continuous knot spans. It stores some of the basic data of a particular curve,
including its control points, knot vector, and order. Internally it is
represented by an array of \texttt{Span} objects containing the data required to
evaluate many NURBS operations, though they are not accessible to the end-user.

Methods that operate on a single span, rather than the entire curve, involve
evaluating which spans are being affected, then propagating the function call to
the \texttt{Span} objects themselves. The \texttt{getKnotSpanIndex(t)} method
returns the index of the knot span containing the value $t$. The result is
always a single span and never a set of spans. If the value $t$ is itself a knot
with a multiplicity greater than one, the function returns the first span after
the multiple knot, and never the zero-length span containing the knot $t$.

\subsection{Span}

The \texttt{Span} class defines a segment of a curve between two knots. It
shares its order with its parent curve and the number of control points is
limited by its order. A single span does not have a knot vector. The shape of a
span is defined by its basis function, which is in turn defined by the parent
curve's knot vector. This basis function is defined in the code as a $(p+1)$ by
$(p+1)$ matrix, where $p$ represents the span's order, and is stored in each
span.

For the sake of performance and memory efficiency, the \texttt{Span} class does
not store its control points, but instead caches the dot product of the weights
with the basis function, as well as the weighted control points with the basis
function, as required by Equation \eqref{eq:nurbs_point} for the evaluation of a
point on the curve.

Whenever the curve's knot vector is modified, the affected spans use the
\texttt{update} method to recompute their basis functions as defined in Equation
\eqref{eq:basisfunc}. Afterwards they recompute their cached control point and
weight matrices using the \texttt{updateControlPoints} method.

\section{Key method implementations}

The \texttt{Curve} class has several constructors, however the main intended
method of instantiation is using a sequence of control points. The curve's order
defaults to three but can be specified. The knot vector is optional, and if it
is not provided a uniformly spaced knot vector is generated. If weights are not
specified they are all set to $1.0$. As per the definition of NURBS, the number
of control points for a curve of degree $p$ must be equal or greater than $p+1$.
Given a sequence of $N$ control points, an order $p$ and a knot vector, the
constructor generates $N-p$ \texttt{Span} objects.

The \texttt{Span} constructor takes a subset of control points, a subset of a
knot vector and the span's order. The first step is to generate the span's basis
function based on the given knot vector segment and order. The basis function is
computed according to Equation \eqref{eq:basisfunc} and stored in the span.
Using the basis function and the weighted control point segment the span
computes the product of the basis function with the control point matrix, and
the basis function with the weight vector, named \texttt{cached\_vbf\_} and
\texttt{cached\_wbf\_} respectively. After calculating and caching these data
members, the span is returned and stored in the curve object.

The \texttt{valueAt} method directly implements Equation \eqref{eq:nurbs_point}
using matrix notation. The helper function \texttt{\_powSeries(t, p)} computes
the powers of $t$ up to $p$ in accordance with Equation \eqref{eq:t_powseries}.

\begin{minted}{cpp}
    Point Span::valueAt(double u) const { Eigen::RowVectorXd pw = _powSeries(u,
    p_); return (pw * cached_vbf_) / pw.dot(cached_wbf_); }
\end{minted}

The \texttt{length} method approximates the total length of a curve. Exact
calculation of the length of any polynomial parametric curve of the third degree
or higher in closed form is not possible. The method instead uses Chebyshev
approximation to calculate the length of the span with a negligible error
\texttt{epsilon}, equal to the margin of error in C++ doubles.

The \texttt{boundingBox} method creates an axis-aligned bounding box (AABB)
around the curve. It does this using the \texttt{extrema} method to find all
local maxima and minima on the $x$ and $y$ axis, and finding the ones with the
highest and lowest values.

The \texttt{extrema} method and the \texttt{roots} method both use Eigen's
polynomial solver module to find the roots of a polynomial, in this case the
derivative and the span itself respectively.

\subsection{Piecewise linear representation}

The \texttt{polyline} method creates a sequence of points suitable for drawing
or other purposes when only an approximation of the curve is needed. One
possible way, and the simplest way to implement this would be to iterate over a
fixed number of uniformly spaced $t$ values. However, this can cause problems as
it does not take into account the scale of the curve and its curvature; a curve
could have the same number of points as another curve ten times its length, and
a curve that is equal to a straight line could have the same number of points as
one with many sharp twists.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\linewidth]{polyline_example.png}
    \caption{Illustration of one step of the polyline algorithm. $p=3$}
    \label{fig:polyline_example}
\end{figure}


The \texttt{polyline} method takes a \texttt{flatness} argument which defines
the tolerance for the error between the linear approximation and the actual
curve. The implementation uses iterative subdivision to approximate the curve.
For each knot span of the curve, the method checks $p-1$ equally spaced internal
points between the beginning and end of the span, and finds the maximum distance
from the chord created by the segment's beginning and end point. The points on
the curve are projected onto the line segment. If the distance from the line
segment to the actual curve is within the threshold defined as
\texttt{flatness}, the segment is added to the final line. Otherwise, it is
subdivided further at the point with maximum deviation. This is illustrated in
Figure \ref{fig:polyline_example}.

\subsection{Piecewise B\'ezier representation}

As discussed in Chapter \ref{chp:comparison}, it is possible to represent
B\'ezier curves as NURBS. Similarly, a NURBS curve can be converted into a
series of B\'ezier curves. Converting a NURBS with modified weights results in
rational B\'ezier curves, whereas an unweighted NURBS (i.e. a B-spline) will
produce regular B\'ezier curves.

\subsection{Derivative evaluation}

The \texttt{derivativeAt} method computes the $n$-th derivative of the curve on
a given point $t$. The order of the derivative is not limited, however higher
values for n can result in slow performance. The helper method
\texttt{\_powSeriesDerivative} calculates the derivative of the power series of
$t$, which amounts to differentiating each of the elements individually.

\begin{equation*}
    \begin{aligned}
        \mathbf{U}_k(t) &= \begin{bmatrix}
            1, t, t^2, t^3, \dots, t^k
        \end{bmatrix} \\
        \frac{d}{dt} \mathbf{U}_k(t) &= \begin{bmatrix}
            0, 1, 2t, 3t^2, \dots, kt^{k-1}
        \end{bmatrix} \\
        \frac{d^2}{dt^2} \mathbf{U}_k(t) &= \begin{bmatrix}
            0, 0, 2, 6t, \dots, k(k-1)t^{k-2}
        \end{bmatrix} \\
        \dots
    \end{aligned}
\end{equation*}

The method then iteratively calculates the derivatives from the first to the
$n$-th according to Equation \eqref{eq:nurbs_derivative}, using the previous
derivative in each consecutive calculation.

The \texttt{extrema} method calculates the positions of all extrema of the curve
on the $x$ and $y$ axis. One use case of this is calculating the bounding box of
the curve or span, as done in the \texttt{boundingBox} method in the
\texttt{Span} class. The \texttt{boundingBox} method in the \texttt{Curve}
class, on the other hand, gets the bounding boxes of all its spans and finds
their minimum and maximum.

\subsection{Curve and span splitting}

the \texttt{\_splittingCoeffs} helper function creates a pair of matrices which,
when multiplied with a span's basis function, splits the span into two new spans
at a given point $t$.

This function is used in methods such as \texttt{polyline} and
\texttt{intersections}, but also in the \texttt{Curve} class for literal curve
splitting.

\subsection{Intersections between curves}
Finding all intersections between two spans is known to be impossible. Instead,
an iterative method is used to approximate the intersections with an error of
\texttt{epsilon}.

The \texttt{intersections} method uses a similar algorithm to the
\texttt{polyline} method to determine if a span is approximately a straight
line. Instead of a queue of subcurves, it keeps a queue of \emph{pairs} of
subcurves to be checked against each other. The queue is populated with both
whole spans in the beginning. For each pair in the queue, it first checks their
bounding boxes to see if they possibly don't overlap at all. If they do, the
method then checks if the diagonals of the bounding boxes are of
\texttt{epsilon} length, or if the subcurves are an approximately straight line.
If not, both subcurves are split at $t=0.5$ using previously cached splitting
matrices, and all combinations of the four curves are added into the queue. As
the subcurves are split, they eventually reach the exit condition, in which case
their intersection is calculated as the intersection of straight line
approximations of the two subdivided parts.

\end{document}