\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Robot path visualisation}
\label{chp:robotpathvisual}

\section{Qt Framework}

Qt is a C++ framework for the development of native desktop applications.For the
purpose of debugging the NURBS library and demonstrating its functionalities, a
program was created using Qt and C++.

The central element in a Qt program is the \texttt{QMainWindow} class, which the
user extends and modifies to their own needs. This window can be configured with
\emph{widgets} and custom behaviour. In this case, a \texttt{MainWindow} class
was created with methods that connect the user interface to methods from the
NURBS library using \emph{signals} and \emph{slots}, two mechanisms on which the
Qt framework heavily relies on.

\begin{minted}[linenos]{cpp}
MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent), ui(new Ui::MainWindow), scene(new CustomScene)
    {
    ui->setupUi(this);
    ui->graphicsView->setScene(scene);
    new QGraphicsViewZoom(ui->graphicsView);

    Eigen::MatrixX2d cp1, cp2;
    cp1.resize(4, 2);
    cp2.resize(5, 2);

    cp1 << 84, 162, 246, 30, 48, 236, 180, 110;
    cp2 << 180, 110, 175, 160, 60, 48, 164, 165, 124, 134;

    NURBS::Curve curve1(cp1 * 5);
    NURBS::Curve curve2(cp2 * 5);

    addCurveToScene(curve1);
    addCurveToScene(curve2);
    ...
    }
\end{minted}

Signals and slots are Qt's way of implementing the listener design pattern. A
class defines signals that it may emit when a specific event happens; for
example, a \texttt{QButton} will have a public signal \texttt{pressed} that
emits whenever the button is pressed. A slot can be any member function and can
be connected to a signal. The slot function gets called when the signal emits.
The signal may or may not have arguments that it passes to whichever slot is
connected to it. This could be a numerical value in a number input, or an index
in a set of radio buttons. A signal can be connected to any slot with matching
arguments. A signal can be connected to any number of slots, and a slot can be
triggered by any number of signals. This is the main way to achieve interaction
between elements in Qt.

% TODO slika cijelog interfacea ovdje

\subsection{Graphics view}

The actual visualization of NURBS paths was done using the
\texttt{QGraphicsView} module. This module implements various drawing functions
including those for drawing line segments and points.

A graphics view widget must be initialized with a \texttt{QGraphicsScene} which
manages objects to be drawn as well as handling user input. Each object in a
scene must inherit from \texttt{QGraphicsObject}. a \texttt{CustomScene} class
was created to handle drawing multiple curves on the screen.

The class \texttt{qCurve}, which inherits from both \texttt{QGraphicsObject} and
\texttt{Curve}, was created as a wrapper to provide Qt drawing functionality to
a NURBS curve. It overrides some methods to 

Overloading the \texttt{paint} function of \texttt{QGraphicsObject} allows us to
define how we want our object to be drawn in a \texttt{QGraphicsView} widget. In
the case of NURBS curves, this means that it is possible to draw not just the
curve itself, but other data associated with it, such as its control points,
knots, or its bounding box. The \texttt{polyline} method defined in the NURBS
library creates a sequence of points for the express purpose of quick and simple
visualization. On every scene update each curve's polyline is recomputed and
drawn using the \texttt{drawLine} method of the \texttt{QPainter} class.

The open-source Qt widget \emph{QCustomPlot} is used to visualize the basis functions
of the selected curve\footnote{Available at \url{https://www.qcustomplot.com/}}.
The plotting is done by taking each span's basis matrix and sampling it over an
interval of $[0,1]$, adjusted to the knot span's actual beginning and end in the
knot vector.

\subsection{User interaction}

Several methods have been implemented for the user to interact with a NURBS
curve in the custom scene, both for debugging and to make sure the curves are
intuitive to work with and manipulate.

The \texttt{qCurve} class draws some additional information along with the curve
itself. It draws the control points which can be dragged to modify the curve.
Along the length of the curve it draws the edges of the knot spans. It can draw
the bounding box around the curve, and display the curvature as a series of
perpendicular lines. Any of these functions can be enabled and disabled using
keyboard shortcuts.

% TODO slika bounding boxa i curvaturea

The \texttt{CustomScene} class overrides several methods od
\texttt{QGraphicsScene} in order to implement the functionality required to
interact with the curves. This is done through the \texttt{mousePressEvent},  
\texttt{mouseMoveEvent} and \texttt{mouseReleaseEvent} methods.

% \begin{minted}{cpp}
% protected:
%     void drawForeground(QPainter* painter, const QRectF& rect) Q_DECL_OVERRIDE;
%     void mousePressEvent(QGraphicsSceneMouseEvent* mouseEvent) Q_DECL_OVERRIDE;
%     void mouseMoveEvent(QGraphicsSceneMouseEvent* mouseEvent) Q_DECL_OVERRIDE;
%     void mouseReleaseEvent(QGraphicsSceneMouseEvent* mouseEvent) Q_DECL_OVERRIDE;
% \end{minted}

The \texttt{mousePressEvent} method handles any mouse presses inside the scene.
When the left mouse button is pressed, it checks for collision with each curve
and control point in the scene. If a curve was clicked, it becomes selected.
Control points can be dragged and moved around the scene. Holding the right
mouse button projects a line onto the selected curve and draws its tangent.

% TODO slika tangente ovdje

Underneath the graphics view are a few other widgets for editing the currently
selected curve. The \texttt{qVectorField} widget was created to edit
fixed-length arrays of data, namely for knot vectors and weights for the active
curve. On the left side is a \texttt{QListWidget} with a custom item type,
\texttt{qCurveListItem}, which makes a curve active upon being selected in the
list.

\section{RViz}

For testing in a simulation environment and designing paths for mobile robots a
plugin was created for the RViz tool often used for visualization of robots.

\subsection{Robot Operating System}
The \emph{Robot Operating System}, or ROS for short, provides a standardized
interface between user programs and robot architecture, and is commonly used in
the field of robotics. 

ROS is mainly built upon the concept of \emph{publishers} and \emph{subscribers}
sending and receiving data among each other. A publisher sends \emph{messages},
which can contain various different types of data, to a \emph{topic}. These will
often contain user commands, sensor data or other real-time information that a
robot might use. A subscriber subscribes to a topic and receives all messages
sent to that topic. Subscribers may receive commands for a robot, but also
collect data from a robot's sensors to show to the user.

\subsection{PathStamped message}

The message type used to describe a mobile robot's path is defined as
\texttt{PathStamped}. The message contains information relevant to the robot and
the user such as the path's start and end points and their types. The section
that unambiguously describes the NURBS curve contains its degree, its weighted
control points and its knot vector. This information is used by the plugin to
construct a NURBS object and use its functions. This means that the sender does
not need to use the NURBS library; the message may be predefined in a file or
created by a different NURBS implementation.


\subsection{RViz plugin development}

RViz listens for ROS messages of a given type and, upon receiving data, draws
the data appropriately. In this case, the message is a Path with timestamps,
named \texttt{PathStamped}. It supports custom plugins written in C++ that add
support for drawing custom message types.

RViz itself is created in Qt which means it reuses many of Qt's concepts when it
comes to plugin development. One important feature is the ability to add custom
editable properties in the GUI. When making a plugin, each property provides a
\emph{signal} that is emitted when the property is edited, which can be
connected to \emph{slots} that execute when the signal emits.

While it uses Qt for its user interface, RViz also uses the \emph{Ogre}
(Object-oriented Graphics Rendering Engine) library to render its 3D scenes and
manage objects in a scene.

Two line drawing methods are implemented: BillboardLine and ManualObject.

\end{document}